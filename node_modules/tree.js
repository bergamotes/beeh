#!/usr/bin/env node

/*
 * tree.js v0.0
 * 2020/03/11 - Edouard De Grave (edouarddegrave@gmail.com)
 * on node v12.13.1
 *
 * Description:
 *    Display nested objects
 *    Mimics Unix tree output to console:
 *       .<svg> main
 *       ├──<g> firstID
 *       ├──<g> secondID
 *       │   ├──<rect> grandchildID
 *       │   ├──<line> noID
 *       │   └──<g> nestgID
 *       │       └──<text> noID
 *       └──<g> waybelowID
 *
 * Requires:
 *    nodejs >= 8
 *
 * Exports:
 *    { tree, nest, hierarchy }
 *    tree exposes format() and target() methods to its closure
 *
 * Usage:
 *    Object must be in {id: foo, [more properties...], children: [{},{}]} format
 *    Use nest function to convert flat array of objects (must include parentID) to appropriate format
 *
 *    tree(): exposes a closure with format() and target() methods. Provides currying.
 *      .format(attr, value): setter for prefix attributes. Value can be a function for "node" attribute
 *      .target(path): if nesting properties are deep within object
 *      .(obj): display nested object to console
 *
 *    nest(arr): convert flat array of objects into nested object
 *    hierarchy(obj): walks through nested objects to filter out selected properties
 *
 * Example:
 *    const { tree } = require('./tree')
 *    const o = {type:"svg",id:1,children:[{type:"g",id:2,children:[{type:"rect",id:3,children:[]}]},{type:"text",id:4,children:[]}]}
 *    const display = tree()
 *       display.format("node", d => `<${d.type}> ${d.id}`)
 *       display(o)
 *    >>>
 *    .<svg> 1
 *    ├──<g> 2
 *    │   └──<rect> 3
 *    └──<text> 4
 *
 * Notes:
 *    Originally made to display svg content hierarchy
 *    Used in @halley/svg.js
 *
 * See:
 *    d3.js tree: https://github.com/d3/d3-hierarchy/blob/master/README.md
 *    https://stackoverflow.com/questions/18017869/build-tree-array-from-flat-array - in -javascript
 */


const tree = () => {
    // returns closures that outputs string as in unix tree command
    const elt = {
        middle: '├──',
        last: '└──',
        parent: { middle: '    ', last: '│   ' },
        color: { reset: "\x1b[0m", red: "\x1b[31m" },
        node: d => `<${d}>`
    }

    let target = "objectRoot"

    const render = (node, parent, children) => {
        // node:object, parent:array, children:boolean
        let prefix = (!parent.length) ? '.' :
            parent.map((d, i) => {
                if (i < parent.length - 1) return ((d) ? elt.parent.middle : elt.parent.last)
                if (d) { color = elt.color.red; return elt.last; }
                return elt.middle
            })
            .join('')

        return `${prefix}${children ? elt.color.reset : elt.color.red}${elt.node(node)}${elt.color.reset}`
    }

    const view = (node, parent = []) => {
        // outputs as in unix tree command
        // node: object with children property, parent: array
        let children = (node.children.length) // boolean
        console.log(render(node, parent, children))
        if (children) node.children.forEach((d, i) => view(target === "objectRoot" ? d : d[target], [...parent, (i == (node.children.length - 1))]));
    }

    view.format = (attr, value, obj = elt) => {
        // setter for prefix attributes
        // attr:string, value:string OR attr:object
        // handles nested attributes (ex: parent.middle) - recursive
        if (!attr) return elt
        if (typeof attr === 'object' && attr !== null) return Object.assign(elt, attr)
        const [head, ...rest] = attr.split('.')
        if (!rest.length) {
            if (!value) return obj[attr]
            obj[head] = value
        } else view.format(rest, value, obj[head])
        return view
    }

    view.target = path => {
        // setter for target if obj hierarchy is nested within provided object
        if (!path) return target
        target = path
        return view
    }
    return view
}

const nest = dataset => {
    // flat array of objects to nested json object
    // each object in dataset must have ID and parent property. IDs must(?) be numbers
    // https://stackoverflow.com/questions/18017869/build-tree-array-from-flat-array - in -javascript
    let hashTable = Object.create(null)
    dataset.forEach((d, i) => hashTable[i] = { ...d, childNodes: [] })
    let dataTree = []
    dataset.forEach(d => {
        if (d.parent) hashTable[d.parent].childNodes.push(hashTable[d.ID])
        else dataTree.push(hashTable[d.ID])
    })
    return dataTree
}

const hierarchy = node => {
    // Walks through nested objects to filter out selected properties
    let dataTree = {}
    dataTree[node.type] = node.id
    if (node.children.length) {
        dataTree.children = []
        node.children.forEach(d => dataTree.children.push(hierarchy(d)))
    }
    return dataTree
}

const hierarchyR = obj => {
    // Walks through nested objects to filter out selected properties
    const array = Array.isArray(obj) ? obj : [obj];
    return array.reduce((acc, node) => {
        acc[node.type] = node.id || "noID"
        if (node.children.length) acc.children = node.children.map(child => hierarchyR(child))
        return acc
    }, {})
}

module.exports = {
    tree,
    hierarchy,
    nest
}

/*
const { hierarchy, hierarchyR } = require('./tree')
const o = {type:"svg",id:1,children:[{type:"g",id:2,children:[{type:"rect",id:3,children:[]}]},{type:"text",id:4,children:[]}]}
*/