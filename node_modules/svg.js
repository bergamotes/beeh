#!/usr/bin/env node

/*
 * svg.js v0.0
 * 2020/03/06 - Edouard De Grave (edouarddegrave@gmail.com)
 * on node v12.13.1
 *
 * Description:
 *    SVG goodies
 *    Mirrors d3.js implementation without need for a DOM
 *    Provides currying
 *
 * Requires:
 *    nodejs >= v8
 *    @halley.tree.js
 *
 * Exports:
 *    { make }
 *
 * Usage:
 *    const svg = require("./svg")
 *    svg.make(element[, id, parent])
 *    The returned render function has the following properties and methods:
 *       - render.obj  : element's identity object (type, id, parent, children)
 *       - render.elt(value:string)
 *       - render.id(value:string)
 *       - render.width(value:number)
 *       - render.height(value:number)
 *       - render.transform(value:string)
 *       - render.attr(attr:string, value:string)
 *       - render.append(elt:string, id:string) : returns instance of newly created element
 *       - render.tree()  : expot and display svg structure
 *
 *
 * Example:
 *   const { make } = require("./svg")
 *   const root = make("svg", "main")
 *   const a = root.append("g","first")
 *   const b = root.append("g", "second")
 *   const c = b.append("rect", "grandchild")
 *   root.append("g","below")
 *   b.append("line")
 *   b.append("g","whatnow").append("text")
 *   root.tree()
 *
 *   newgroup = svg.make("g","mygroup")  // create
 *   newgroup.translate(5,5).rotate(90) // update
 *   newgroup.append("<line x2....>") // append element
 *   newgroup.append("<rect width=...">)) // append other element
 *   newgroup() // returns completed svg string
 *
 * Notes:
 *
 * See:
 *   - SVG specification : https://www.w3.org/TR/SVG2/struct.html
 *   - d3.js : https://github.com/d3/d3/wiki
 *
 */


const { tree } = require("./tree.js")

//Container element : an element which can have graphics elements and other container elements as child elements.
const containerElements = ["a", "clipPath", "defs", "g", "linearGradient", "marker", "mask", "pattern", "radialGradient", "svg", "switch", "symbol", "unknown"]
const textElements = ["text", "tspan", "textPath"]

function* generateHeader(elt, attributes) {
    // generator function. Use (for .. of ..) loop to exhaust
    if (elt.type === 'svg') {
        yield '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"'
    } else {
        yield '<' + elt.type
    }
    if (elt.id) yield ` id="${elt.id}"`
    for (const [attr, value] of Object.entries(attributes)) {
        yield ` ${attr}="${value}"`
    }
    if (elt.selfClosing) yield '/>'
    else yield '>'
}

function make(eltType = "svg", id = "", parentID = null) {

    const e = {
        type: eltType,
        id: id,
        parent: parentID,
        children: [],
        nchild: 0,
        selfClosing: true
    }

    let attributes = Object.create(e);
    let text = [];

    const render = () => {
        let stub = "";
        for (item of generateHeader(e, attributes)) stub += item
        // add children elements if any and close
        if (e.selfClosing) return stub
        if (text.length) return stub + text.map(d => (typeof d === 'string') ? d : d()).join('') + `</${e.type}>`
        if (e.children.length) return stub + e.children.map(d => d()).join('') + `</${e.type}>`
        return stub + `</${e.type}>`
    }

    render.obj = e

    render.elt = function(value) {
        if (!arguments.length) return e.type
        e.type = value
        return render
    }

    render.id = function(value) {
        if (!arguments.length) return attributes.hasOwnProperty('id') ? attributes.id : id
        attributes['id'] = value
        return render
    }

    render.x = function(x) {
        if (!arguments.length) return attributes.x
        attributes['x'] = x
        return render
    }

    render.y = function(y) {
        if (!arguments.length) return attributes.y
        attributes['y'] = y
        return render
    }

    render.width = function(w) {
        if (!arguments.length) return attributes.width
        attributes['width'] = w
        return render
    }

    render.height = function(h) {
        if (!arguments.length) return attributes.height
        attributes['height'] = h
        return render
    }

    render.translate = (x = 0, y = 0) => {
        if (attributes.transform) attributes['transform'] += ` translate(${x} ${y})`
        else attributes['transform'] = `translate(${x} ${y})`
        return render
    }

    render.rotate = (r = 0, rx = 0, ry = 0) => {
        if (attributes.transform) attributes['transform'] += ` rotate(${r} ${rx} ${ry})`
        else attributes['transform'] += `rotate(${r} ${rx} ${ry})`
        return render
    }

    render.scale = (sx = 0, sy = 0) => {
        if (attributes.transform) attributes['transform'] += ` scale(${sx} ${sy})`
        else attributes['transform'] = `scale(${sx} ${sy})`
        return render
    }

    render.transform = function(t) {
        if (!arguments.length) return attributes.transform
        attributes['transform'] = t
        return render
    }

    render.attr = function(attr, value) {
        if (arguments.length == 1) return attributes[attr]
        if (!arguments.length) return attributes
        attributes[attr] = value
        return render
    }

    render.tree = () => {
        const display = tree().target("obj") // e.obj if where hierarchy is to be found [children]
        display.format("node", d => `<${d.type}> ${d.id}`)
        display(e)
    }

    // if (elt.match(/^(a|clipPath|defs|g|marker|mask|pattern|svg|switch|symbol|unknown)$/)){
    if (containerElements.includes(e.type)) {

        e.selfClosing = false

        render.append = function(eltType, id) {
            if (!arguments.length) return e.children
            parent = (parentID === null) ? 0 : parentID + 1
            e.children.push(make(eltType, id, parent))
            return e.children[e.nchild++]
        }
    }

    if (textElements.includes(e.type)) {

        e.selfClosing = false

        render.text = function(string) {
            if (!arguments.length) return text.map(d => (typeof d === 'string') ? d : d.text()).join(' ')
            text.push(string)
            return render
        }

        if (e.type === "text") {

            render.text.append = function(eltType, id) {
                if (!arguments.length) return e.children
                parent = (parentID === null) ? 0 : parentID + 1
                e.children.push(make(eltType, id, parent))
                text.push(e.children[e.nchild])
                return e.children[e.nchild++]
            }
        }
    }

    return render
}

const path = d => '<path d="' + d + '"/>'
const rect = (x, y, w, h) => {
    return '<rect x="' + x + '" y="' + y + '" width="' + w + '" height="' + h + '"/>'
};
const text = (t, x, y) => '<text x="' + x + '" y="' + y + '">' + t + '</text>'


module.exports = {
    make: make
}